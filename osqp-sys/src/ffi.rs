/* automatically generated by rust-bindgen */

pub type c_int = ::std::os::raw::c_longlong;
pub type c_float = f64;
pub const linsys_solver_type_SUITESPARSE_LDL_SOLVER: linsys_solver_type = 0;
pub const linsys_solver_type_MKL_PARDISO_SOLVER: linsys_solver_type = 1;
pub type linsys_solver_type = ::std::os::raw::c_uint;
/// Matrix in compressed-column or triplet form
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csc {
    /// < maximum number of entries.
    pub nzmax: c_int,
    /// < number of rows
    pub m: c_int,
    /// < number of columns
    pub n: c_int,
    /// < column pointers (size n+1) (col indices (size nzmax) start from 0 when using triplet format (direct KKT matrix formation))
    pub p: *mut c_int,
    /// < row indices, size nzmax starting from 0
    pub i: *mut c_int,
    /// < numerical values, size nzmax
    pub x: *mut c_float,
    /// < # of entries in triplet matrix, -1 for csc
    pub nz: c_int,
}
#[test]
fn bindgen_test_layout_csc() {
    assert_eq!(
        ::std::mem::size_of::<csc>(),
        56usize,
        concat!("Size of: ", stringify!(csc))
    );
    assert_eq!(
        ::std::mem::align_of::<csc>(),
        8usize,
        concat!("Alignment of ", stringify!(csc))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).nzmax as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(csc),
            "::",
            stringify!(nzmax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).m as *const _ as usize },
        8usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(m))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).n as *const _ as usize },
        16usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).p as *const _ as usize },
        24usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).i as *const _ as usize },
        32usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(i))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).x as *const _ as usize },
        40usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).nz as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(csc),
            "::",
            stringify!(nz)
        )
    );
}
/// Linear system solver structure (sublevel objects initialize it differently)
pub type LinSysSolver = linsys_solver;
/// OSQP Timer for statistics
pub type OSQPTimer = OSQP_TIMER;
/// Problem scaling matrices stored as vectors
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPScaling {
    /// < cost function scaling
    pub c: c_float,
    /// < primal variable scaling
    pub D: *mut c_float,
    /// < dual variable scaling
    pub E: *mut c_float,
    /// < cost function rescaling
    pub cinv: c_float,
    /// < primal variable rescaling
    pub Dinv: *mut c_float,
    /// < dual variable rescaling
    pub Einv: *mut c_float,
}
#[test]
fn bindgen_test_layout_OSQPScaling() {
    assert_eq!(
        ::std::mem::size_of::<OSQPScaling>(),
        48usize,
        concat!("Size of: ", stringify!(OSQPScaling))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPScaling>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPScaling))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).c as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).D as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(D)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).E as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(E)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).cinv as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(cinv)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).Dinv as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(Dinv)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).Einv as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(Einv)
        )
    );
}
/// Solution structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPSolution {
    /// < Primal solution
    pub x: *mut c_float,
    /// < Lagrange multiplier associated to \f$l <= Ax <= u\f$
    pub y: *mut c_float,
}
#[test]
fn bindgen_test_layout_OSQPSolution() {
    assert_eq!(
        ::std::mem::size_of::<OSQPSolution>(),
        16usize,
        concat!("Size of: ", stringify!(OSQPSolution))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPSolution>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPSolution))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSolution)).x as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSolution),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSolution)).y as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSolution),
            "::",
            stringify!(y)
        )
    );
}
/// Solver return nformation
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPInfo {
    /// < number of iterations taken
    pub iter: c_int,
    /// < status string, e.g. 'solved'
    pub status: [::std::os::raw::c_char; 32usize],
    /// < status as c_int, defined in constants.h
    pub status_val: c_int,
    /// < polish status: successful (1), unperformed (0), (-1) unsuccessful
    pub status_polish: c_int,
    /// < primal objective
    pub obj_val: c_float,
    /// < norm of primal residual
    pub pri_res: c_float,
    /// < norm of dual residual
    pub dua_res: c_float,
    /// < time taken for setup phase (seconds)
    pub setup_time: c_float,
    /// < time taken for solve phase (seconds)
    pub solve_time: c_float,
    /// < time taken for polish phase (seconds)
    pub polish_time: c_float,
    /// < total time  (seconds)
    pub run_time: c_float,
    /// < number of rho updates
    pub rho_updates: c_int,
    /// < best rho estimate so far from residuals
    pub rho_estimate: c_float,
}
#[test]
fn bindgen_test_layout_OSQPInfo() {
    assert_eq!(
        ::std::mem::size_of::<OSQPInfo>(),
        128usize,
        concat!("Size of: ", stringify!(OSQPInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPInfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).iter as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(iter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).status as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).status_val as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(status_val)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).status_polish as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(status_polish)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).obj_val as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(obj_val)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).pri_res as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(pri_res)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).dua_res as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(dua_res)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).setup_time as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(setup_time)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).solve_time as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(solve_time)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).polish_time as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(polish_time)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).run_time as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(run_time)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).rho_updates as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(rho_updates)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).rho_estimate as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(rho_estimate)
        )
    );
}
/// Polish structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPPolish {
    /// < Active rows of A.
    /// ///<    Ared = vstack[Alow, Aupp]
    pub Ared: *mut csc,
    /// < number of lower-active rows
    pub n_low: c_int,
    /// < number of upper-active rows
    pub n_upp: c_int,
    /// < Maps indices in A to indices in Alow
    pub A_to_Alow: *mut c_int,
    /// < Maps indices in A to indices in Aupp
    pub A_to_Aupp: *mut c_int,
    /// < Maps indices in Alow to indices in A
    pub Alow_to_A: *mut c_int,
    /// < Maps indices in Aupp to indices in A
    pub Aupp_to_A: *mut c_int,
    /// < optimal x-solution obtained by polish
    pub x: *mut c_float,
    /// < optimal z-solution obtained by polish
    pub z: *mut c_float,
    /// < optimal y-solution obtained by polish
    pub y: *mut c_float,
    /// < objective value at polished solution
    pub obj_val: c_float,
    /// < primal residual at polished solution
    pub pri_res: c_float,
    /// < dual residual at polished solution
    pub dua_res: c_float,
}
#[test]
fn bindgen_test_layout_OSQPPolish() {
    assert_eq!(
        ::std::mem::size_of::<OSQPPolish>(),
        104usize,
        concat!("Size of: ", stringify!(OSQPPolish))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPPolish>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPPolish))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).Ared as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(Ared)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).n_low as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(n_low)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).n_upp as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(n_upp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).A_to_Alow as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(A_to_Alow)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).A_to_Aupp as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(A_to_Aupp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).Alow_to_A as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(Alow_to_A)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).Aupp_to_A as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(Aupp_to_A)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).x as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).z as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).y as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).obj_val as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(obj_val)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).pri_res as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(pri_res)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).dua_res as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(dua_res)
        )
    );
}
/// Data structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPData {
    /// < number of variables n,
    pub n: c_int,
    /// < number of constraints m
    pub m: c_int,
    /// < P: in csc format (size n x n). The workspace version stores only the upper triangular part. P->nzmax is the number of nonzero elements of the full P.
    pub P: *mut csc,
    /// < A: in csc format (size m x n)
    pub A: *mut csc,
    /// < dense array for linear part of cost function (size n)
    pub q: *mut c_float,
    /// < dense array for lower bound (size m)
    pub l: *mut c_float,
    /// < dense array for upper bound (size m)
    pub u: *mut c_float,
}
#[test]
fn bindgen_test_layout_OSQPData() {
    assert_eq!(
        ::std::mem::size_of::<OSQPData>(),
        56usize,
        concat!("Size of: ", stringify!(OSQPData))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPData>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).n as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).m as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).P as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).A as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).q as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).l as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).u as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(u)
        )
    );
}
/// Settings struct
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPSettings {
    /// < ADMM step rho
    pub rho: c_float,
    /// < ADMM step sigma
    pub sigma: c_float,
    /// < heuristic data scaling iterations. If 0, scaling disabled
    pub scaling: c_int,
    /// < boolean, is rho step size adaptive?
    pub adaptive_rho: c_int,
    /// < Number of iterations between rho adaptations rho. If 0, it is automatic
    pub adaptive_rho_interval: c_int,
    /// < Tolerance X for adapting rho. The new rho has to be X times larger or 1/X times smaller than the current one to trigger a new factorization.
    pub adaptive_rho_tolerance: c_float,
    /// < Interval for adapting rho (fraction of the setup time)
    pub adaptive_rho_fraction: c_float,
    /// < maximum iterations
    pub max_iter: c_int,
    /// < absolute convergence tolerance
    pub eps_abs: c_float,
    /// < relative convergence tolerance
    pub eps_rel: c_float,
    /// < primal infeasibility tolerance
    pub eps_prim_inf: c_float,
    /// < dual infeasibility tolerance
    pub eps_dual_inf: c_float,
    /// < relaxation parameter
    pub alpha: c_float,
    /// < linear system solver to use
    pub linsys_solver: linsys_solver_type,
    /// < regularization parameter for polish
    pub delta: c_float,
    /// < boolean, polish ADMM solution
    pub polish: c_int,
    /// < iterative refinement steps in polish
    pub polish_refine_iter: c_int,
    /// < boolean, write out progres
    pub verbose: c_int,
    /// < boolean, use scaled termination criteria
    pub scaled_termination: c_int,
    /// < integer, check termination interval. If 0, termination checking is disabled
    pub check_termination: c_int,
    /// < boolean, warm start
    pub warm_start: c_int,
}
#[test]
fn bindgen_test_layout_OSQPSettings() {
    assert_eq!(
        ::std::mem::size_of::<OSQPSettings>(),
        168usize,
        concat!("Size of: ", stringify!(OSQPSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPSettings))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).rho as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(rho)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).sigma as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(sigma)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).scaling as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).adaptive_rho as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(adaptive_rho)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).adaptive_rho_interval as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(adaptive_rho_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).adaptive_rho_tolerance as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(adaptive_rho_tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).adaptive_rho_fraction as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(adaptive_rho_fraction)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).max_iter as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(max_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).eps_abs as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(eps_abs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).eps_rel as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(eps_rel)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).eps_prim_inf as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(eps_prim_inf)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).eps_dual_inf as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(eps_dual_inf)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).alpha as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).linsys_solver as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(linsys_solver)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).delta as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).polish as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(polish)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).polish_refine_iter as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(polish_refine_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).verbose as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).scaled_termination as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(scaled_termination)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).check_termination as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(check_termination)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).warm_start as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(warm_start)
        )
    );
}
/// OSQP Workspace
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPWorkspace {
    /// Problem data to work on (possibly scaled)
    pub data: *mut OSQPData,
    /// Linear System solver structure
    pub linsys_solver: *mut LinSysSolver,
    /// Polish structure
    pub pol: *mut OSQPPolish,
    /// < vector of rho values
    pub rho_vec: *mut c_float,
    /// < vector of inv rho values
    pub rho_inv_vec: *mut c_float,
    /// < Type of constraints: loose (-1), equality (1), inequality (0)
    pub constr_type: *mut c_int,
    /// < Iterate x
    pub x: *mut c_float,
    /// < Iterate y
    pub y: *mut c_float,
    /// < Iterate z
    pub z: *mut c_float,
    /// < Iterate xz_tilde
    pub xz_tilde: *mut c_float,
    /// < Previous x
    /// /**< NB: Used also as workspace vector for dual residual */
    pub x_prev: *mut c_float,
    /// < Previous z
    /// /**< NB: Used also as workspace vector for primal residual */
    pub z_prev: *mut c_float,
    /// < Scaled A * x
    pub Ax: *mut c_float,
    /// < Scaled P * x
    pub Px: *mut c_float,
    /// < Scaled A * x
    pub Aty: *mut c_float,
    /// < Difference of consecutive dual iterates
    pub delta_y: *mut c_float,
    /// < A' * delta_y
    pub Atdelta_y: *mut c_float,
    /// < Difference of consecutive primal iterates
    pub delta_x: *mut c_float,
    /// < P * delta_x
    pub Pdelta_x: *mut c_float,
    /// < A * delta_x
    pub Adelta_x: *mut c_float,
    /// < temporary primal variable scaling vectors
    pub D_temp: *mut c_float,
    /// < temporary primal variable scaling vectors storing norms of A columns
    pub D_temp_A: *mut c_float,
    /// < temporary constraints scaling vectors storing norms of A' columns
    pub E_temp: *mut c_float,
    /// < Problem settings
    pub settings: *mut OSQPSettings,
    /// < Scaling vectors
    pub scaling: *mut OSQPScaling,
    /// < Problem solution
    pub solution: *mut OSQPSolution,
    /// < Solver information
    pub info: *mut OSQPInfo,
    /// < Timer object
    pub timer: *mut OSQPTimer,
    /// flag indicating whether the solve function has been run before
    pub first_run: c_int,
    /// < Has last summary been printed? (true/false)
    pub summary_printed: c_int,
}
#[test]
fn bindgen_test_layout_OSQPWorkspace() {
    assert_eq!(
        ::std::mem::size_of::<OSQPWorkspace>(),
        240usize,
        concat!("Size of: ", stringify!(OSQPWorkspace))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPWorkspace>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPWorkspace))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).linsys_solver as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(linsys_solver)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).pol as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(pol)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).rho_vec as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(rho_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).rho_inv_vec as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(rho_inv_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).constr_type as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(constr_type)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).x as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).y as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).z as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).xz_tilde as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(xz_tilde)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).x_prev as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(x_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).z_prev as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(z_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Ax as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Ax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Px as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Px)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Aty as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Aty)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).delta_y as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(delta_y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Atdelta_y as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Atdelta_y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).delta_x as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(delta_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Pdelta_x as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Pdelta_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Adelta_x as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Adelta_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).D_temp as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(D_temp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).D_temp_A as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(D_temp_A)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).E_temp as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(E_temp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).settings as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(settings)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).scaling as *const _ as usize },
        192usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).solution as *const _ as usize },
        200usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(solution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).info as *const _ as usize },
        208usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).timer as *const _ as usize },
        216usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).first_run as *const _ as usize },
        224usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(first_run)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).summary_printed as *const _ as usize },
        232usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(summary_printed)
        )
    );
}
/// Define linsys_solver prototype structure
///
/// NB: The details are defined when the linear solver is initialized depending
/// on the choice
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linsys_solver {
    /// < Linear system solver type (see type.h)
    pub type_: linsys_solver_type,
    /// < Solve linear system
    pub solve: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut LinSysSolver,
            b: *mut c_float,
            settings: *const OSQPSettings,
        ) -> c_int,
    >,
    /// < Free linear system solver (only in desktop version)
    pub free: ::std::option::Option<unsafe extern "C" fn(self_: *mut LinSysSolver)>,
    /// < Update matrices P and A in the solver
    pub update_matrices: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut LinSysSolver,
            P: *const csc,
            A: *const csc,
            settings: *const OSQPSettings,
        ) -> c_int,
    >,
    /// < Update rho
    pub update_rho_vec: ::std::option::Option<
        unsafe extern "C" fn(s: *mut LinSysSolver, rho_vec: *const c_float, m: c_int) -> c_int,
    >,
    /// < Number of threads active
    pub nthreads: c_int,
}
#[test]
fn bindgen_test_layout_linsys_solver() {
    assert_eq!(
        ::std::mem::size_of::<linsys_solver>(),
        48usize,
        concat!("Size of: ", stringify!(linsys_solver))
    );
    assert_eq!(
        ::std::mem::align_of::<linsys_solver>(),
        8usize,
        concat!("Alignment of ", stringify!(linsys_solver))
    );
    assert_eq!(
        unsafe { &(*(0 as *const linsys_solver)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(linsys_solver),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const linsys_solver)).solve as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(linsys_solver),
            "::",
            stringify!(solve)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const linsys_solver)).free as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(linsys_solver),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const linsys_solver)).update_matrices as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(linsys_solver),
            "::",
            stringify!(update_matrices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const linsys_solver)).update_rho_vec as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(linsys_solver),
            "::",
            stringify!(update_rho_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const linsys_solver)).nthreads as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(linsys_solver),
            "::",
            stringify!(nthreads)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_timebase_info {
    pub numer: u32,
    pub denom: u32,
}
#[test]
fn bindgen_test_layout_mach_timebase_info() {
    assert_eq!(
        ::std::mem::size_of::<mach_timebase_info>(),
        8usize,
        concat!("Size of: ", stringify!(mach_timebase_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_timebase_info>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_timebase_info))
    );
    assert_eq!(
        unsafe { &(*(0 as *const mach_timebase_info)).numer as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(mach_timebase_info),
            "::",
            stringify!(numer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const mach_timebase_info)).denom as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(mach_timebase_info),
            "::",
            stringify!(denom)
        )
    );
}
pub type mach_timebase_info_data_t = mach_timebase_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQP_TIMER {
    pub tic: u64,
    pub toc: u64,
    pub tinfo: mach_timebase_info_data_t,
}
#[test]
fn bindgen_test_layout_OSQP_TIMER() {
    assert_eq!(
        ::std::mem::size_of::<OSQP_TIMER>(),
        24usize,
        concat!("Size of: ", stringify!(OSQP_TIMER))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQP_TIMER>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQP_TIMER))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQP_TIMER)).tic as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQP_TIMER),
            "::",
            stringify!(tic)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQP_TIMER)).toc as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQP_TIMER),
            "::",
            stringify!(toc)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQP_TIMER)).tinfo as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQP_TIMER),
            "::",
            stringify!(tinfo)
        )
    );
}
extern "C" {

    /// Initialize OSQP solver allocating memory.
    ///
    /// All the inputs must be already allocated in memory before calling.
    ///
    /// It performs:
    /// - data and settings validation
    /// - problem data scaling
    /// - automatic parameters tuning (if enabled)
    /// - setup linear system solver:
    /// - direct solver: KKT matrix factorization is performed here
    /// - indirect solver: KKT matrix preconditioning is performed here
    ///
    /// NB: This is the only function that allocates dynamic memory and is not used during code generation
    ///
    /// @param  data         Problem data
    /// @param  settings     Solver settings
    /// @return              Solver environment

    #[link_name = "\u{1}_osqp_setup"]
    pub fn osqp_setup(data: *const OSQPData, settings: *mut OSQPSettings) -> *mut OSQPWorkspace;
}
extern "C" {

    /// Solve quadratic program
    ///
    /// The final solver information is stored in the \a work->info  structure
    ///
    /// The solution is stored in the  \a work->solution  structure
    ///
    /// If the problem is primal infeasible, the certificate is stored
    /// in \a work->delta_y
    ///
    /// If the problem is dual infeasible, the certificate is stored in \a
    /// work->delta_x
    ///
    /// @param  work Workspace allocated
    /// @return      Exitflag for errors

    #[link_name = "\u{1}_osqp_solve"]
    pub fn osqp_solve(work: *mut OSQPWorkspace) -> c_int;
}
extern "C" {

    /// Cleanup workspace by deallocating memory
    ///
    /// This function is not used in code generation
    /// @param  work Workspace
    /// @return      Exitflag for errors

    #[link_name = "\u{1}_osqp_cleanup"]
    pub fn osqp_cleanup(work: *mut OSQPWorkspace) -> c_int;
}
extern "C" {

    /// Update linear cost in the problem
    /// @param  work  Workspace
    /// @param  q_new New linear cost
    /// @return       Exitflag for errors and warnings

    #[link_name = "\u{1}_osqp_update_lin_cost"]
    pub fn osqp_update_lin_cost(work: *mut OSQPWorkspace, q_new: *mut c_float) -> c_int;
}
extern "C" {

    /// Update lower and upper bounds in the problem constraints
    /// @param  work   Workspace
    /// @param  l_new New lower bound
    /// @param  u_new New upper bound
    /// @return        Exitflag: 1 if new lower bound is not <= than new upper bound

    #[link_name = "\u{1}_osqp_update_bounds"]
    pub fn osqp_update_bounds(
        work: *mut OSQPWorkspace,
        l_new: *mut c_float,
        u_new: *mut c_float,
    ) -> c_int;
}
extern "C" {

    /// Update lower bound in the problem constraints
    /// @param  work   Workspace
    /// @param  l_new New lower bound
    /// @return        Exitflag: 1 if new lower bound is not <= than upper bound

    #[link_name = "\u{1}_osqp_update_lower_bound"]
    pub fn osqp_update_lower_bound(work: *mut OSQPWorkspace, l_new: *mut c_float) -> c_int;
}
extern "C" {

    /// Update upper bound in the problem constraints
    /// @param  work   Workspace
    /// @param  u_new New upper bound
    /// @return        Exitflag: 1 if new upper bound is not >= than lower bound

    #[link_name = "\u{1}_osqp_update_upper_bound"]
    pub fn osqp_update_upper_bound(work: *mut OSQPWorkspace, u_new: *mut c_float) -> c_int;
}
extern "C" {

    /// Warm start primal and dual variables
    /// @param  work Workspace structure
    /// @param  x    Primal variable
    /// @param  y    Dual variable
    /// @return      Exitflag

    #[link_name = "\u{1}_osqp_warm_start"]
    pub fn osqp_warm_start(work: *mut OSQPWorkspace, x: *mut c_float, y: *mut c_float) -> c_int;
}
extern "C" {

    /// Warm start primal variable
    /// @param  work Workspace structure
    /// @param  x    Primal variable
    /// @return      Exitflag

    #[link_name = "\u{1}_osqp_warm_start_x"]
    pub fn osqp_warm_start_x(work: *mut OSQPWorkspace, x: *mut c_float) -> c_int;
}
extern "C" {

    /// Warm start dual variable
    /// @param  work Workspace structure
    /// @param  y    Dual variable
    /// @return      Exitflag

    #[link_name = "\u{1}_osqp_warm_start_y"]
    pub fn osqp_warm_start_y(work: *mut OSQPWorkspace, y: *mut c_float) -> c_int;
}
extern "C" {

    /// Update elements of matrix P (upper-diagonal)
    /// without changing sparsity structure.
    ///
    ///
    /// If Px_new_idx is OSQP_NULL, Px_new is assumed to be as long as P->x
    /// and the whole P->x is replaced.
    ///
    /// @param  work       Workspace structure
    /// @param  Px_new     Vector of new elements in P->x (upper triangular)
    /// @param  Px_new_idx Index mapping new elements to positions in P->x
    /// @param  P_new_n    Number of new elements to be changed
    /// @return            output flag:  0: OK
    /// 1: P_new_n > nnzP
    /// <0: error in the update

    #[link_name = "\u{1}_osqp_update_P"]
    pub fn osqp_update_P(
        work: *mut OSQPWorkspace,
        Px_new: *mut c_float,
        Px_new_idx: *mut c_int,
        P_new_n: c_int,
    ) -> c_int;
}
extern "C" {

    /// Update elements of matrix A without changing sparsity structure.
    ///
    ///
    /// If Ax_new_idx is OSQP_NULL, Ax_new is assumed to be as long as A->x
    /// and the whole P->x is replaced.
    ///
    /// @param  work       Workspace structure
    /// @param  Ax_new     Vector of new elements in A->x
    /// @param  Ax_new_idx Index mapping new elements to positions in A->x
    /// @param  A_new_n    Number of new elements to be changed
    /// @return            output flag:  0: OK
    /// 1: A_new_n > nnzA
    /// <0: error in the update

    #[link_name = "\u{1}_osqp_update_A"]
    pub fn osqp_update_A(
        work: *mut OSQPWorkspace,
        Ax_new: *mut c_float,
        Ax_new_idx: *mut c_int,
        A_new_n: c_int,
    ) -> c_int;
}
extern "C" {

    /// Update elements of matrix P (upper-diagonal) and elements of matrix A
    /// without changing sparsity structure.
    ///
    ///
    /// If Px_new_idx is OSQP_NULL, Px_new is assumed to be as long as P->x
    /// and the whole P->x is replaced.
    ///
    /// If Ax_new_idx is OSQP_NULL, Ax_new is assumed to be as long as A->x
    /// and the whole P->x is replaced.
    ///
    /// @param  work       Workspace structure
    /// @param  Px_new     Vector of new elements in P->x (upper triangular)
    /// @param  Px_new_idx Index mapping new elements to positions in P->x
    /// @param  P_new_n    Number of new elements to be changed
    /// @param  Ax_new     Vector of new elements in A->x
    /// @param  Ax_new_idx Index mapping new elements to positions in A->x
    /// @param  A_new_n    Number of new elements to be changed
    /// @return            output flag:  0: OK
    /// 1: P_new_n > nnzP
    /// 2: A_new_n > nnzA
    /// <0: error in the update

    #[link_name = "\u{1}_osqp_update_P_A"]
    pub fn osqp_update_P_A(
        work: *mut OSQPWorkspace,
        Px_new: *mut c_float,
        Px_new_idx: *mut c_int,
        P_new_n: c_int,
        Ax_new: *mut c_float,
        Ax_new_idx: *mut c_int,
        A_new_n: c_int,
    ) -> c_int;
}
