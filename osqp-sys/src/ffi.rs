/* automatically generated by rust-bindgen */

pub type __darwin_time_t = ::std::os::raw::c_long;
pub type c_int = ::std::os::raw::c_long;
pub type c_float = f64;
/// Matrix in compressed-column or triplet form
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csc {
    /// < maximum number of entries.
    pub nzmax: c_int,
    /// < number of rows
    pub m: c_int,
    /// < number of columns
    pub n: c_int,
    /// < column pointers (size n+1) (col indices (size nzmax) start from 0 when using triplet format (direct KKT matrix formation))
    pub p: *mut c_int,
    /// < row indices, size nzmax starting from 0
    pub i: *mut c_int,
    /// < numerical values, size nzmax
    pub x: *mut c_float,
    /// < # of entries in triplet matrix, -1 for csc
    pub nz: c_int,
}
#[test]
fn bindgen_test_layout_csc() {
    assert_eq!(
        ::std::mem::size_of::<csc>(),
        56usize,
        concat!("Size of: ", stringify!(csc))
    );
    assert_eq!(
        ::std::mem::align_of::<csc>(),
        8usize,
        concat!("Alignment of ", stringify!(csc))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).nzmax as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(csc),
            "::",
            stringify!(nzmax)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).m as *const _ as usize },
        8usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(m))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).n as *const _ as usize },
        16usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).p as *const _ as usize },
        24usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).i as *const _ as usize },
        32usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(i))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).x as *const _ as usize },
        40usize,
        concat!("Alignment of field: ", stringify!(csc), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(0 as *const csc)).nz as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(csc),
            "::",
            stringify!(nz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c_priv {
    _unused: [u8; 0],
}
/// Linear system solver private structure (internal functions deal with it)
pub type Priv = c_priv;
/// OSQP Timer for statistics
pub type OSQPTimer = OSQP_TIMER;
/// Problem scaling matrices stored as vectors
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPScaling {
    /// < primal variable scaling
    pub D: *mut c_float,
    /// < dual variable scaling
    pub E: *mut c_float,
    /// < primal variable rescaling
    pub Dinv: *mut c_float,
    /// < dual variable rescaling
    pub Einv: *mut c_float,
}
#[test]
fn bindgen_test_layout_OSQPScaling() {
    assert_eq!(
        ::std::mem::size_of::<OSQPScaling>(),
        32usize,
        concat!("Size of: ", stringify!(OSQPScaling))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPScaling>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPScaling))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).D as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(D)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).E as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(E)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).Dinv as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(Dinv)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPScaling)).Einv as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPScaling),
            "::",
            stringify!(Einv)
        )
    );
}
/// Solution structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPSolution {
    /// < Primal solution
    pub x: *mut c_float,
    /// < Lagrange multiplier associated to \f$l <= Ax <= u\f$
    pub y: *mut c_float,
}
#[test]
fn bindgen_test_layout_OSQPSolution() {
    assert_eq!(
        ::std::mem::size_of::<OSQPSolution>(),
        16usize,
        concat!("Size of: ", stringify!(OSQPSolution))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPSolution>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPSolution))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSolution)).x as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSolution),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSolution)).y as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSolution),
            "::",
            stringify!(y)
        )
    );
}
/// Solver return nformation
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPInfo {
    /// < number of iterations taken
    pub iter: c_int,
    /// < status string, e.g. 'Solved'
    pub status: [::std::os::raw::c_char; 32usize],
    /// < status as c_int, defined in constants.h
    pub status_val: c_int,
    /// < polish status: successful (1), unperformed (0), (-1) unsuccessful
    pub status_polish: c_int,
    /// < primal objective
    pub obj_val: c_float,
    /// < norm of primal residual
    pub pri_res: c_float,
    /// < norm of dual residual
    pub dua_res: c_float,
    /// < time taken for setup phase (milliseconds)
    pub setup_time: c_float,
    /// < time taken for solve phase (milliseconds)
    pub solve_time: c_float,
    /// < time taken for polish phase (milliseconds)
    pub polish_time: c_float,
    /// < total time  (milliseconds)
    pub run_time: c_float,
}
#[test]
fn bindgen_test_layout_OSQPInfo() {
    assert_eq!(
        ::std::mem::size_of::<OSQPInfo>(),
        112usize,
        concat!("Size of: ", stringify!(OSQPInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPInfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).iter as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(iter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).status as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).status_val as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(status_val)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).status_polish as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(status_polish)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).obj_val as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(obj_val)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).pri_res as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(pri_res)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).dua_res as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(dua_res)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).setup_time as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(setup_time)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).solve_time as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(solve_time)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).polish_time as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(polish_time)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPInfo)).run_time as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPInfo),
            "::",
            stringify!(run_time)
        )
    );
}
/// Polish structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPPolish {
    /// < Active rows of A.
    /// ///<    Ared = vstack[Alow, Aupp]
    pub Ared: *mut csc,
    /// < number of lower-active rows
    pub n_low: c_int,
    /// < number of upper-active rows
    pub n_upp: c_int,
    /// < Maps indices in A to indices in Alow
    pub A_to_Alow: *mut c_int,
    /// < Maps indices in A to indices in Aupp
    pub A_to_Aupp: *mut c_int,
    /// < Maps indices in Alow to indices in A
    pub Alow_to_A: *mut c_int,
    /// < Maps indices in Aupp to indices in A
    pub Aupp_to_A: *mut c_int,
    /// < optimal x-solution obtained by polish
    pub x: *mut c_float,
    /// < optimal z-solution obtained by polish
    pub z: *mut c_float,
    /// < optimal dual variables associated to Ared obtained
    /// ///<    by polish
    pub y_red: *mut c_float,
    /// < objective value at polished solution
    pub obj_val: c_float,
    /// < primal residual at polished solution
    pub pri_res: c_float,
    /// < dual residual at polished solution
    pub dua_res: c_float,
}
#[test]
fn bindgen_test_layout_OSQPPolish() {
    assert_eq!(
        ::std::mem::size_of::<OSQPPolish>(),
        104usize,
        concat!("Size of: ", stringify!(OSQPPolish))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPPolish>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPPolish))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).Ared as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(Ared)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).n_low as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(n_low)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).n_upp as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(n_upp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).A_to_Alow as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(A_to_Alow)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).A_to_Aupp as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(A_to_Aupp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).Alow_to_A as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(Alow_to_A)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).Aupp_to_A as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(Aupp_to_A)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).x as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).z as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).y_red as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(y_red)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).obj_val as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(obj_val)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).pri_res as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(pri_res)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPPolish)).dua_res as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPPolish),
            "::",
            stringify!(dua_res)
        )
    );
}
/// Data structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPData {
    /// < number of variables n,
    pub n: c_int,
    /// < number of constraints m
    pub m: c_int,
    /// < P: in csc format (size n x n)
    pub P: *mut csc,
    /// < A: in csc format (size m x n)
    pub A: *mut csc,
    /// < dense array for linear part of cost function (size n)
    pub q: *mut c_float,
    /// < dense array for lower bound (size m)
    pub l: *mut c_float,
    /// < dense array for upper bound (size m)
    pub u: *mut c_float,
}
#[test]
fn bindgen_test_layout_OSQPData() {
    assert_eq!(
        ::std::mem::size_of::<OSQPData>(),
        56usize,
        concat!("Size of: ", stringify!(OSQPData))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPData>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPData))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).n as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).m as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).P as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).A as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).q as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).l as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPData)).u as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPData),
            "::",
            stringify!(u)
        )
    );
}
/// Settings struct
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPSettings {
    /// < ADMM step rho
    pub rho: c_float,
    /// < ADMM step sigma
    pub sigma: c_float,
    /// < boolean, heuristic data rescaling
    pub scaling: c_int,
    /// < scaling iteration
    pub scaling_iter: c_int,
    /// < maximum iterations to tak
    pub max_iter: c_int,
    /// < absolute convergence tolerance
    pub eps_abs: c_float,
    /// < relative convergence tolerance
    pub eps_rel: c_float,
    /// < primal infeasibility tolerance
    pub eps_prim_inf: c_float,
    /// < dual infeasibility tolerance
    pub eps_dual_inf: c_float,
    /// < relaxation paramete
    pub alpha: c_float,
    /// < regularization parameter for polis
    pub delta: c_float,
    /// < boolean, polish ADMM solutio
    pub polish: c_int,
    /// < iterative refinement steps in polis
    pub pol_refine_iter: c_int,
    /// < boolean, write out progres
    pub verbose: c_int,
    /// < boolean, true if rho is chosen automatically
    pub auto_rho: c_int,
    /// < boolean, use scaled termination criteria
    pub scaled_termination: c_int,
    /// < boolean, terminate if stopping criteria is met
    pub early_terminate: c_int,
    /// < boolean, interval for checking termination, if early_terminate == 1
    pub early_terminate_interval: c_int,
    /// < boolean, warm start
    pub warm_start: c_int,
}
#[test]
fn bindgen_test_layout_OSQPSettings() {
    assert_eq!(
        ::std::mem::size_of::<OSQPSettings>(),
        152usize,
        concat!("Size of: ", stringify!(OSQPSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPSettings))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).rho as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(rho)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).sigma as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(sigma)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).scaling as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).scaling_iter as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(scaling_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).max_iter as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(max_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).eps_abs as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(eps_abs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).eps_rel as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(eps_rel)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).eps_prim_inf as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(eps_prim_inf)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).eps_dual_inf as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(eps_dual_inf)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).alpha as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).delta as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).polish as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(polish)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).pol_refine_iter as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(pol_refine_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).verbose as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).auto_rho as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(auto_rho)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).scaled_termination as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(scaled_termination)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).early_terminate as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(early_terminate)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).early_terminate_interval as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(early_terminate_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPSettings)).warm_start as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPSettings),
            "::",
            stringify!(warm_start)
        )
    );
}
/// OSQP Workspace
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQPWorkspace {
    /// Problem data to work on (possibly scaled)
    pub data: *mut OSQPData,
    /// Linear System solver structure
    pub priv_: *mut Priv,
    /// Polish structure
    pub pol: *mut OSQPPolish,
    /// < Iterate x
    pub x: *mut c_float,
    /// < Iterate y
    pub y: *mut c_float,
    /// < Iterate z
    pub z: *mut c_float,
    /// < Iterate xz_tilde
    pub xz_tilde: *mut c_float,
    /// < Previous x
    /// /**< N.B. Used also as workspace vector for dual residual */
    pub x_prev: *mut c_float,
    /// < Previous z
    /// /**< N.B. Used also as workspace vector for primal residual */
    pub z_prev: *mut c_float,
    /// < Difference of dual iterates
    pub delta_y: *mut c_float,
    /// < A' * delta_y
    pub Atdelta_y: *mut c_float,
    /// < Difference of consecutive primal iterates
    pub delta_x: *mut c_float,
    /// < P * delta_x
    pub Pdelta_x: *mut c_float,
    /// < A * delta_x
    pub Adelta_x: *mut c_float,
    /// < temporary primal variable scaling vectors
    pub D_temp: *mut c_float,
    /// < temporary primal variable scaling vectors storing norms of A columns
    pub D_temp_A: *mut c_float,
    /// < temporary constraints scaling vectors storing norms of A' columns
    pub E_temp: *mut c_float,
    /// < Problem settings
    pub settings: *mut OSQPSettings,
    /// < Scaling Vectors
    pub scaling: *mut OSQPScaling,
    /// < Problem Solution
    pub solution: *mut OSQPSolution,
    /// < Solver information
    pub info: *mut OSQPInfo,
    /// < Timer object
    pub timer: *mut OSQPTimer,
    /// flag indicating whether the solve function has been run before
    pub first_run: c_int,
    /// < Has last summary been printed? (true/false)
    pub summary_printed: c_int,
}
#[test]
fn bindgen_test_layout_OSQPWorkspace() {
    assert_eq!(
        ::std::mem::size_of::<OSQPWorkspace>(),
        192usize,
        concat!("Size of: ", stringify!(OSQPWorkspace))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQPWorkspace>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQPWorkspace))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).priv_ as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).pol as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(pol)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).x as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).y as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).z as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).xz_tilde as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(xz_tilde)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).x_prev as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(x_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).z_prev as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(z_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).delta_y as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(delta_y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Atdelta_y as *const _ as usize },
        80usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Atdelta_y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).delta_x as *const _ as usize },
        88usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(delta_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Pdelta_x as *const _ as usize },
        96usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Pdelta_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).Adelta_x as *const _ as usize },
        104usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(Adelta_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).D_temp as *const _ as usize },
        112usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(D_temp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).D_temp_A as *const _ as usize },
        120usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(D_temp_A)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).E_temp as *const _ as usize },
        128usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(E_temp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).settings as *const _ as usize },
        136usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(settings)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).scaling as *const _ as usize },
        144usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).solution as *const _ as usize },
        152usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(solution)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).info as *const _ as usize },
        160usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).timer as *const _ as usize },
        168usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).first_run as *const _ as usize },
        176usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(first_run)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQPWorkspace)).summary_printed as *const _ as usize },
        184usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQPWorkspace),
            "::",
            stringify!(summary_printed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(0 as *const timespec)).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const timespec)).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSQP_TIMER {
    pub tic: timespec,
    pub toc: timespec,
}
#[test]
fn bindgen_test_layout_OSQP_TIMER() {
    assert_eq!(
        ::std::mem::size_of::<OSQP_TIMER>(),
        32usize,
        concat!("Size of: ", stringify!(OSQP_TIMER))
    );
    assert_eq!(
        ::std::mem::align_of::<OSQP_TIMER>(),
        8usize,
        concat!("Alignment of ", stringify!(OSQP_TIMER))
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQP_TIMER)).tic as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQP_TIMER),
            "::",
            stringify!(tic)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const OSQP_TIMER)).toc as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(OSQP_TIMER),
            "::",
            stringify!(toc)
        )
    );
}
extern "C" {

    /// Initialize OSQP solver allocating memory.
    ///
    /// All the inputs must be already allocated in memory before calling.
    ///
    /// It performs:
    /// - data and settings validation
    /// - problem data scaling
    /// - automatic parameters tuning (if enabled)
    /// - setup linear system solver:
    /// - direct solver: KKT matrix factorization is performed here
    ///
    /// N.B. This is the only function that allocates dynamic memory and is not used during code generation
    ///
    /// @param  data         Problem data
    /// @param  settings     Solver settings
    /// @return              Solver environment

    #[link_name = "\u{1}_osqp_setup"]
    pub fn osqp_setup(data: *const OSQPData, settings: *mut OSQPSettings) -> *mut OSQPWorkspace;
}
extern "C" {

    /// Solve quadratic program
    ///
    /// The final solver information is stored in the \a work->info  structure
    ///
    /// The solution is stored in the  \a work->solution  structure
    ///
    /// If the problem is primal infeasible, the certificate is stored
    /// in \a work->delta_y
    ///
    /// If the problem is dual infeasible, the certificate is stored in \a
    /// work->delta_x
    ///
    /// @param  work Workspace allocated
    /// @return      Exitflag for errors

    #[link_name = "\u{1}_osqp_solve"]
    pub fn osqp_solve(work: *mut OSQPWorkspace) -> c_int;
}
extern "C" {

    /// Cleanup workspace by deallocating memory
    ///
    /// This function is not used in code generation
    /// @param  work Workspace
    /// @return      Exitflag for errors

    #[link_name = "\u{1}_osqp_cleanup"]
    pub fn osqp_cleanup(work: *mut OSQPWorkspace) -> c_int;
}
extern "C" {

    /// Update linear cost in the problem
    /// @param  work  Workspace
    /// @param  q_new New linear cost
    /// @return       Exitflag for errors and warnings

    #[link_name = "\u{1}_osqp_update_lin_cost"]
    pub fn osqp_update_lin_cost(work: *mut OSQPWorkspace, q_new: *mut c_float) -> c_int;
}
extern "C" {

    /// Update lower and upper bounds in the problem constraints
    /// @param  work   Workspace
    /// @param  l_new New lower bound
    /// @param  u_new New upper bound
    /// @return        Exitflag: 1 if new lower bound is not <= than new upper bound

    #[link_name = "\u{1}_osqp_update_bounds"]
    pub fn osqp_update_bounds(
        work: *mut OSQPWorkspace,
        l_new: *mut c_float,
        u_new: *mut c_float,
    ) -> c_int;
}
extern "C" {

    /// Update lower bound in the problem constraints
    /// @param  work   Workspace
    /// @param  l_new New lower bound
    /// @return        Exitflag: 1 if new lower bound is not <= than upper bound

    #[link_name = "\u{1}_osqp_update_lower_bound"]
    pub fn osqp_update_lower_bound(work: *mut OSQPWorkspace, l_new: *mut c_float) -> c_int;
}
extern "C" {

    /// Update upper bound in the problem constraints
    /// @param  work   Workspace
    /// @param  u_new New upper bound
    /// @return        Exitflag: 1 if new upper bound is not >= than lower bound

    #[link_name = "\u{1}_osqp_update_upper_bound"]
    pub fn osqp_update_upper_bound(work: *mut OSQPWorkspace, u_new: *mut c_float) -> c_int;
}
extern "C" {

    /// Warm start primal and dual variables
    /// @param  work Workspace structure
    /// @param  x    Primal variable
    /// @param  y    Dual variable
    /// @return      Exitflag

    #[link_name = "\u{1}_osqp_warm_start"]
    pub fn osqp_warm_start(work: *mut OSQPWorkspace, x: *mut c_float, y: *mut c_float) -> c_int;
}
extern "C" {

    /// Warm start primal variable
    /// @param  work Workspace structure
    /// @param  x    Primal variable
    /// @return      Exitflag

    #[link_name = "\u{1}_osqp_warm_start_x"]
    pub fn osqp_warm_start_x(work: *mut OSQPWorkspace, x: *mut c_float) -> c_int;
}
extern "C" {

    /// Warm start dual variable
    /// @param  work Workspace structure
    /// @param  y    Dual variable
    /// @return      Exitflag

    #[link_name = "\u{1}_osqp_warm_start_y"]
    pub fn osqp_warm_start_y(work: *mut OSQPWorkspace, y: *mut c_float) -> c_int;
}
extern "C" {

    /// Update elements of matrix P (upper-diagonal)
    /// without changing sparsity structure.
    ///
    ///
    /// If Px_new_idx is OSQP_NULL, Px_new is assumed to be as long as P->x
    /// and the whole P->x is replaced.
    ///
    /// @param  work       Workspace structure
    /// @param  Px_new     Vector of new elements in P->x (upper triangular)
    /// @param  Px_new_idx Index mapping new elements to positions in P->x
    /// @param  P_new_n    Number of new elements to be changed
    /// @return            output flag:  0: OK
    /// 1: P_new_n > nnzP
    /// <0: error in update_priv()

    #[link_name = "\u{1}_osqp_update_P"]
    pub fn osqp_update_P(
        work: *mut OSQPWorkspace,
        Px_new: *mut c_float,
        Px_new_idx: *mut c_int,
        P_new_n: c_int,
    ) -> c_int;
}
extern "C" {

    /// Update elements of matrix A without changing sparsity structure.
    ///
    ///
    /// If Ax_new_idx is OSQP_NULL, Ax_new is assumed to be as long as A->x
    /// and the whole P->x is replaced.
    ///
    /// @param  work       Workspace structure
    /// @param  Ax_new     Vector of new elements in A->x
    /// @param  Ax_new_idx Index mapping new elements to positions in A->x
    /// @param  A_new_n    Number of new elements to be changed
    /// @return            output flag:  0: OK
    /// 1: A_new_n > nnzA
    /// <0: error in update_priv()

    #[link_name = "\u{1}_osqp_update_A"]
    pub fn osqp_update_A(
        work: *mut OSQPWorkspace,
        Ax_new: *mut c_float,
        Ax_new_idx: *mut c_int,
        A_new_n: c_int,
    ) -> c_int;
}
extern "C" {

    /// Update elements of matrix P (upper-diagonal) and elements of matrix A
    /// without changing sparsity structure.
    ///
    ///
    /// If Px_new_idx is OSQP_NULL, Px_new is assumed to be as long as P->x
    /// and the whole P->x is replaced.
    ///
    /// If Ax_new_idx is OSQP_NULL, Ax_new is assumed to be as long as A->x
    /// and the whole P->x is replaced.
    ///
    /// @param  work       Workspace structure
    /// @param  Px_new     Vector of new elements in P->x (upper triangular)
    /// @param  Px_new_idx Index mapping new elements to positions in P->x
    /// @param  P_new_n    Number of new elements to be changed
    /// @param  Ax_new     Vector of new elements in A->x
    /// @param  Ax_new_idx Index mapping new elements to positions in A->x
    /// @param  A_new_n    Number of new elements to be changed
    /// @return            output flag:  0: OK
    /// 1: P_new_n > nnzP
    /// 2: A_new_n > nnzA
    /// <0: error in update_priv()

    #[link_name = "\u{1}_osqp_update_P_A"]
    pub fn osqp_update_P_A(
        work: *mut OSQPWorkspace,
        Px_new: *mut c_float,
        Px_new_idx: *mut c_int,
        P_new_n: c_int,
        Ax_new: *mut c_float,
        Ax_new_idx: *mut c_int,
        A_new_n: c_int,
    ) -> c_int;
}
